[{"title":"机器学习(之)特征工程","date":"2020-10-25T03:51:04.000Z","path":"2020/Feature_MachineLearning/","text":"跳转到导航栏 特征工程定义：特征工程是将原始数据转化成更好地代表预测模型潜在问题的特征的工程，从而提高了对未知数据的预测准确性。 sklearn库中特征提取APIsklearn.feature_extraction对字典数据进行特征值化sklearn.feature_extraction.DictVectorizerDictVectorizer语法 123456789101112DictVectorizer(sparse=True, ...) 用sparse为数据在于节约内存，方便读取处理。DictVectorizer.fit_transform(x) x:字典或者包含字典的迭代器 返回值：返回sparse矩阵DictVectorizer.inverse_transform(x) x:array数组或者sparse矩阵 返回值：转换之前数据格式DictVectorizer.get_feature_names() 返回类别名称DictVectorizer.transform(x) 按照原先的标准转换 对多篇文章分析，文本特征提取 123456789101112131415161718192021222324from sklearn.feature_extraction.text import CountVectorizer# fit(数据)输入数据 计算平均值 方差等# fit_transform(数据) = fit(数据) + transform(数据)进行数据转换def countvec(): \"\"\" 对文本进行特征值化 :return: None \"\"\" cv = CountVectorizer() # 统计所有文章当中所有的词，相当于set data = cv.fit_transform( [\"life is short, i like python\", \"life is too long, i dislike python\"] ) # 对每篇文章，在词的列表里面进行统计每个词出现的次数 # 单个字母不统计，因为单个字母表达不了一个意思。 print( cv.get_feature_names()) print( data.toarray() ) return None输出 &gt;&gt;&gt;['dislike', 'is', 'life', 'like', 'long', 'python', 'short', 'too'][[0 1 1 1 0 1 1 0] [1 1 1 0 1 1 0 1]] TF-IDF 12345TF：term frequency 词的频率IDF：逆文档频率 inverse document frequency一个词的IDF = log(文档的总数/出现该词的文档数量)一个词的重要（区分度）TF*IDF","comments":true,"tags":[{"name":"AI","slug":"AI","permalink":"https://climbsnail.github.io/tags/AI/"}]},{"title":"机器学习(之)数据预处理","date":"2020-10-25T01:23:34.000Z","path":"2020/Preprocess_MachineLearning/","text":"跳转到导航栏 数据处理 数值型数据：标准缩放 归一化 标准化 缺失值 类别型数据：one-hot编码 时间类型：时间的切分 一、数据的归一化处理12345678910特点：通过对原始数据进行变化，把数据映射到[0,1](默认)之间，可以让不同类别特征值之间达到&quot;平衡&quot;,数值操作的时候达到同等重要的作用。公式：x1 &#x3D; (x-min)&#x2F;(max-min) x2 &#x3D; x1*(max-min)+min注：作用于每一列，max为一列的最大值，min为一列的最小值归一化API sklearn.preprocessing.MinMaxScalerfrom sklearn.preprocessing.MinMaxScaler import MinMaxScalerMinMaxScaler(feature_range&#x3D;(0,1), ...)MinMaxScaler.fit_transform(x) x: numpy array格式的数据[n_samples, n_features] 返回值：转换后，形状相同的array 二、数据的标准化（常用）1234标准化可以减少错误数据对最终结果的影响公式：x1 = (x-mean)/标准差，mean为平均值 方差：var = [(x1-mean)^2+(x2-mean)^2+....]/样本个数N。方差体现数据的稳定性。标准差：var^(1/2) 三、有缺失值处理数据中有缺失值时，有时候考虑到数据集本身少，尽量避免删除数据，所以对缺少值进行人为添加值，一般使用改特征的平均数或中位数进行覆盖。 123456789101112131415def im(): \"\"\" 缺失值处理 return None \"\"\" im = Impoter(missing_values='NaN', strategy='mean', axis=0) data = im.fit_transform([[1,2], [np.nan,3], [7,6]]) print(data) \"\"\" 输出 [[1, 2] [4, 3] [7, 6]] \"\"\" return None 降维：使对结果不重要的特征尽可能不影响结果（将该特征删除，维度只的是特征个数） 降维主要方法： Filter过略式 VarianceThreshold Embedded嵌入式 正则化、决策树 Wrapper包裹式1234567891011121314def var(): \"\"\" 特征选择 删除低方差的特征 return None \"\"\" var = VarianceThreshold(threshold=1.0) # 删除方差小于1的 data = var.fit_transform([[0,2,0,3], [0,1,4,3], [0,1,1,3]]) print(data) \"\"\" [[2, 0] [1, 4] [1,1]] \"\"\" return None","comments":true,"tags":[{"name":"AI","slug":"AI","permalink":"https://climbsnail.github.io/tags/AI/"}]},{"title":"认识人工智能","date":"2020-10-25T00:41:22.000Z","path":"2020/Background_MachineLearning/","text":"跳转到导航栏 文字相关的概念 人工智能：目的 机器学习：一种实现人工智能的方法 深度学习：一种实现机器学习的技术 推荐书籍 周志华 机器学习 python数据分析与挖掘实战 机器学习系统设计 面向机器智能TensorFlow实践 TensorFlow技术解析与实践 学习路线 数据预处理、特征工程 模型、策略、优化 分类、回归和聚类 Tensorflow 神经网络 图像识别 自然语言处理 基础知识 由于数据库性能低，数据读取慢，格式也不太符合机器学习要求的数据格式。所以机器学习的数据一般储存在文本文件中，例如csv文件。 读取数据使用pandas工具，pandas是基于numpy库使用C语言编写的，从底层释放python的GIL锁，实现真正的多线程。 sklearn：对特征的处理提供强大的接口。 可用的现成数据集： scikit-learn：是一个库，数据量小方便学习。文档完善，丰富的API，包括许多知名机器学习算法的实现。 123安装Scikit-learn需要Numpy、pandas等库pip install Scikit-learnimport sklearn UCI：收录了360个数据集；覆盖科学、生活、经济等领域；数据量十几万 Kaggle：大数据竞赛平台；80万科学家；真实数据；数据量巨大； 数据的格式：特征值+目标 注：一般情况下都是字符文字，需要预处理成数值数据，进而方便对数据的计算。 用户数据(需清洗) -&gt; 数据预处理 -&gt; 特征工程 -&gt; 机器学习 -&gt; 模型评估 -&gt; 提供离线或在线服务（注：如果模型评估不合格需重新进行数据预处理）","comments":true,"tags":[{"name":"AI","slug":"AI","permalink":"https://climbsnail.github.io/tags/AI/"}]},{"title":"深度学习","date":"2020-10-25T00:39:22.000Z","path":"2020/DeepLearningMain/","text":"快速导航 了解人工智、机器学习等相关概念及背景。Background_MachineLearning 机器学习（之）数据预处理。Preprocess_MachineLearning 机器学习（之）特征工程。Feature_MachineLearning 等待更新。。。。","comments":true,"tags":[{"name":"AI","slug":"AI","permalink":"https://climbsnail.github.io/tags/AI/"}]},{"title":"多种GitHub加速方式","date":"2020-08-07T06:12:31.000Z","path":"2020/GithubSpeed/","text":"1. GitHub 镜像访问 2. GitHub文件加速 3. Github 加速下载 4. 加速你的 Github 5. 谷歌浏览器GitHub加速插件(推荐) 6. GitHub raw 加速 7. GitHub + Jsdelivr 8. 通过Gitee中转fork仓库下载 9. 通过修改HOSTS文件进行加速 为什么github下载速度这么慢？ 如何提高github的下载速度？ 第一步：获取github的global.ssl.fastly地址 第二步：获取github.com地址 第三步：修改host文件映射上面查找到的IP 1. GitHub 镜像访问这里提供两个最常用的镜像地址： https://github.com.cnpmjs.org https://hub.fastgit.org 也就是说上面的镜像就是一个克隆版的Github，你可以访问上面的镜像网站，网站的内容跟Github是完整同步的镜像，然后在这个网站里面进行下载克隆等操作。 2. GitHub文件加速利用 Cloudflare Workers 对github release 、archive 以及项目文件进行加速，部署无需服务器且自带CDN. https://gh.api.99988866.xyzhttps://g.ioiox.com 以上网站为演示站点，如无法打开可以查看开源项目：gh-proxy-GitHub 文件加速 自行部署。 3. Github 加速下载只需要复制当前 GitHub 地址粘贴到输入框中就可以代理加速下载！ 地址：http://toolwa.com/github/ 4. 加速你的 Githubhttps://github.zhlh6.cn 输入 Github 仓库地址，使用生成的地址进行 git ssh 等操作 5. 谷歌浏览器GitHub加速插件(推荐)谷歌浏览器Github加速插件.crx 下载百度网盘: https://pan.baidu.com/s/1qGiIUzqNlN1ZczTNFbPg0A ,提取码：stsv 如果可以直接访问谷歌商店，可以访问GitHub加速谷歌商店安装。 6. GitHub raw 加速GitHub raw域名并非 github.com而是raw.githubusercontent.com，上方的GitHub加速如果不能加速这个域名，那么可以使用 Static CDN 提供的反代服务。 将raw.githubusercontent.com替换为raw.staticdn.net即可加速。 7. GitHub + Jsdelivrjsdelivr 唯一美中不足的就是它不能获取 exe 文件以及 Release 处附加的 exe 和 dmg 文件。 也就是说如果 exe 文件是附加在 Release 处但是没有在 code 里面的话是无法获取的。所以只能当作静态文件 cdn 用途，而不能作为 Release 加速下载的用途。# 8. 通过Gitee中转fork仓库下载网上有很多相关的教程，这里简要的说明下操作。 访问gitee网站： https://gitee.com/并登录，在顶部选择“从GitHub/GitLab导入仓库” 如下： 在导入页面中粘贴你的Github仓库地址，点击导入即可： 等待导入操作完成，然后在导入的仓库中下载浏览对应的该GitHub仓库代码，你也可以点击仓库顶部的“刷新”按钮进行Github代码仓库的同步。 9. 通过修改HOSTS文件进行加速参考如下详细介绍 为什么github下载速度这么慢？GitHub 我们都知道是世界上最大的开源及私有软件项目的托管平台，全世界每天有海量优秀的开源软件在这里产生，而 GitHub 在国内很多时候获取到的下载链接是亚马逊的服务器。 中国因为不可言说的原因，经常抽疯或龟速。想要加快 GitHub 下载速度就需要用到 GitHub 国内加速服务，对于有条件的可以使用代理加快访问速度，而没有条件的就可以用到网上热心人士维护的加速服务了。 如何提高github的下载速度？手动把cdn和ip地址绑定。 第一步：获取github的global.ssl.fastly地址访问：http://github.global.ssl.fastly.net.ipaddress.com/#ipinfo获取cdn和ip域名： 得到：199.232.69.194 https://github.global.ssl.fastly.net 第二步：获取github.com地址访问：https://github.com.ipaddress.com/#ipinfo 获取cdn和ip： 得到：140.82.114.3 http://github.com 第三步：修改host文件映射上面查找到的IPwindows系统： 1、修改C:\\Windows\\System32\\drivers\\etc\\hosts文件的权限，指定可写入： 右击-&gt;hosts-&gt;属性-&gt;安全-&gt;编辑-&gt;点击Users-&gt;在Users的权限“写入”后面打勾。如下： 无法显示 然后点击确定。 2、右击-&gt;hosts-&gt;打开方式-&gt;选定记事本（或者你喜欢的编辑器）-&gt;在末尾处添加以下内容： 12199.232.69.194 github.global.ssl.fastly.net140.82.114.4 github.com","comments":true,"tags":[{"name":"教程","slug":"教程","permalink":"https://climbsnail.github.io/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"香橙派 OrangePi Zero plus主频1.3Ghz启动失败","date":"2020-07-01T06:35:43.000Z","path":"2020/OrangePi_Zero_Plus_CPU_Fre/","text":"简要介绍硬件方面OrangePi Zero plus使用的是全志H5芯片。四核A53芯片。 使用的系统是armbian，刷完系统，开机默认运行最高的频率为1008Mhz。 七七八八装了很多软件以及配置了相关的环境。 由于了解到全志H5芯片是可以工作在1.3Ghz的主频上。所以接着就想调节到更高的性能，调节过程中由于主频不适配硬件，导致启动失败。 使用armbian-config命令进行调节主频到1.2Ghz1. 进入系统设置选项 2. 进入硬件调节选项使用的是conservative调节器，有关调节器的介绍放在了文末。 3. 光标通过方向键移动到指定的选项，这里选择1.2V，按空格键勾选选项，设置完毕先Save，后Back。用armbian-config将主频提高到了1.2Ghz，修改主频将在重启之后生效。 4. 重启后，查询状态使用armbian-config查看CPU的频率，这时已经可以在1.2Ghz的频率上工作了。 将主频调至1.3Ghz出现问题后期同样的操作调节主频到1.3Ghz，结果系统没能成功启动。重要的是，我的环境不就白配了吗？？？ 以下是TTL的最后的启动日志。 穿插一段关于联系香橙派售后 先是让帮忙联系技术确定一下板子CPU能不能跑到1.3Ghz，结果客服让等（最后没给任何答复）。 后来查出是硬件缺少Q5后（下文有介绍），再次联系客服，让硬件工程师给个答复:缺少Q5是与不是跑不到1.3Ghz（是与不是的问题），又让我等，最后好几天（当然期间已经自行解决了）过去了还是没给任何答复。 注：个人也觉得这类东西需要自己学习，过多的询问卖家肯定不合理。但是我就只是简单的一个问题，就只是给我一个”是与不是”的答案就够了，压根不花费工程师多少时间。香橙派的服务真是太差了。 好了，开始自己的研究了经过一番查找后，终于占到了问题所在。 这里是OrangePi Zero plus的原理图 https://linux-sunxi.org/images/6/67/ORANGE_PI-ZERO-PLUS_V1_0_Schematic.pdf 可以看到第7页的CPU供电原理图。 左上角标注着两种电压，可以看到这个电压逻辑上是由这个Q5这颗nmos管控制的。 随即查看了手头的这块Zero Plus，发现背板只有一处空余着的焊盘，就在内存卡插槽的上方，而这处恰好是Q5。默认出厂的OrangePi Zero Plus这个Q5是省缺的。 这不，问题找到了，而手头没有BSN20这个贴片(SOT-23封装的N mos)，百度了以下这个BSN20相关参数，从元件盒里找了一片SI2302 (丝印为A2SHB)来代替。 开机，顺利启动！armbian-config命令进设置，可以看到主页面的CPU信息成功调节到480Mhz-1296MHz之间了。 首先，CPU的散热我是使用可固化的STARS922导热胶粘连202010mm的散热片。 后期，我对其进行压力测试，在只跑满两个核心的情况下，五分钟CPU的温度就上到了85度以上，但到达90以上时，就已经开始降频到1Ghz以下了。所以，在没有足够好的散热情况下，不建议将主频调制1.2/1.3Ghz。 cpu调节器(governor) performance：将CPU频率固定工作在其支持的最高运行频率上，不动态调节，可以获取到最大的性能。 powersave: 将 CPU 频率设置为最低的所谓 “省电” 模式，CPU 会固定工作在其支持的最低运行频率上。因此这两种 governors 都属于静态 governor，即在使用它们时 CPU 的运行频率不会根据系统运行时负载的变化动态作出调整。这两种 governors 对应的是两种极端的应用场景，使用 performance governor 是对系统高性能的最大追求，而使用 powersave governor 则是对系统低功耗的最大追求。 Userspace：最早的 cpufreq 子系统通过 userspace governor 为用户提供了这种灵活性。系统将变频策略的决策权交给了用户态应用程序，并提供了相应的接口供用户态应用程序调节 CPU 运行频率使用。 ondemand：按需快速动态调整 CPU 频率， 一有 cpu 计算量的任务，就会立即达到最大频率运行，等执行完毕就立即回到最低频率；ondemand：userspace 是内核态的检测，用户态调整，效率低。 conservative: 与 ondemand 不同，平滑地调整 CPU 频率，频率的升降是渐变式的, 会自动在频率上下限调整，和 ondemand 的区别在于它会按需分配频率，而不是一味追求最高频率; 致谢感谢帮助最大的讨论: https://forum.armbian.com/topic/11967-orange-pi-zero-plus-cpu-frequency-problem/","comments":true,"tags":[{"name":"硬件","slug":"硬件","permalink":"https://climbsnail.github.io/tags/%E7%A1%AC%E4%BB%B6/"}]},{"title":"安卓系统修改钉钉定位","date":"2020-06-07T06:12:31.000Z","path":"2020/DingdingPos/","text":"全过程无需root！！！简单介绍以下方法，通过将钉钉内置到虚拟环境中，再使用钉钉助手修改定位信息。 修改定位需要用到以下三款软件。 太极框架。点击下载太极APP 如失效请使用备用链接 钉钉助手。点击下载钉钉助手v1.4.1 如失效请使用备用链接中找到钉钉助手 指定版本的钉钉。点击下载视频配套的钉钉v4.7.16 如失效请使用钉钉v5.0.8链接 注意：钉钉的版本只能使用钉钉助手中说明的适配版本。 具体教程请观看视频","comments":true,"tags":[{"name":"教程","slug":"教程","permalink":"https://climbsnail.github.io/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"Gitee免费图床搭建以及PicGo的使用","date":"2020-06-01T18:58:10.000Z","path":"2020/UseFor_Gitee_PicGo/","text":"具体教程请观看视频 相关下载 PicGo客户端下载地址：https://github.com/Molunerfinn/PicGo 码云地址：https://gitee.com/ 图片压缩平台： https://www.yasuotu.com/ https://tinypng.com/","comments":true,"tags":[{"name":"静态博客搭建","slug":"静态博客搭建","permalink":"https://climbsnail.github.io/tags/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"基于树莓派的多感知双足机器人","date":"2019-10-06T08:53:23.000Z","path":"2019/Robot_For_RaspberryPi/","text":"You can also read a translated version of this file 英文版 in English or in Korean 한국어. 项目来自我的本科毕业设计 最早之前做过一版，由单片机离线控制的。可以先预览。 Github项目链接 B站视频 https://b23.tv/BV1qs411L7Pn 树莓派拓展板视频 https://b23.tv/BV1zt411u7LR 整个项目为一个软硬件结合的项目，提供整个电路工程文件以及相关功能的所有源代码。 开发语言C、C++、Python、C#。 机器人设计思维结构图 Pictures and 3D-modelPictures 3D-model PCB 3D预览图 文件介绍 RPI_ExpansionBoard_Code （树莓派拓展板内置STM32程序 MDK5工程） RaspberryPi拓展板(STM32C8T6版) （树莓派拓展板AD电路工程文件） 代码结构整个代码的设计遵从高内聚低耦合，每个子模块都可以单独使用，内部都有对应的demo。 robot_main.py （整个机器人的主控制模块，controller） baidu_speak.py （百度语音识别与合成） face_recognition.py （基于opencv的人脸检测与识别） GPIO.py （树莓派拓展板的IO驱动API） read_action.py （动作组文件的读取） snowboydecoder.py （语音唤醒支撑文件） snowboydetect.py （语音唤醒支撑文件） turing_robot.py （图灵机器人对话） playsound.py （windows下音乐播放器） robotsocket.py （与即将开发的windows客户端通信） config.py （处理配置文件） default.cfg （robot_main.py使用的默认配置文件） Action （动作组存放的文件夹） BaiduSpeak （baidu_speak.py默认缓存文件夹） Data （opencv人脸检测的模型文件夹） 其余的为参考图片 补充所有功能都已实现，相关内容等整立完了，统一更新。 相关的windows客户端随后也将更新。","comments":true,"tags":[{"name":"项目","slug":"项目","permalink":"https://climbsnail.github.io/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"我的大学四年","date":"2019-06-28T02:02:24.000Z","path":"2019/FourYearsOfUniversity/","text":"四年，累过、笑过。 说不尽的遗憾，道不完的收获。 很幸运认识了大家，一个又一个集体。 大家都准研究生了，就一个最次的我要工作了。 就想说“gou富贵 勿相忘” 现在总算走了，寝室第一个离开的。 刚刚室友们集体催的“何琦 快走快走，快滚快滚”，我记住了。 好久没去523了，也好久没有在518 516一起拼凳子睡。 毕业了，很伤感。 怀念516进门的第二排的那个座，坐着不再是我。 再见了，工程训练中心518 516 512、五号楼523、M座M411，再见了辽宁科技大学。再见了学生时代。 最后一个句号。 .square{ position: relative; width: 100%; height: 0; padding-bottom: 80%; /* padding百分比是相对父元素宽度计算的 */ margin-bottom: 30px; } .square-inner{ position: absolute; top: 0; left: 0; width: 100%; height: 100%; /* 铺满父元素容器，这时候宽高就始终相等了 */ } .square-inner>li{ width: calc(98% / 3); /* calc里面的运算符两边要空格 */ height: calc(98% / 3); margin-right: 1%; margin-bottom: 1%; overflow: hidden; } .flex{ display: flex; flex-wrap: wrap; } .flex>li{ flex-grow: 1; /* 子元素按1/n的比例进行拉伸 */ text-align: center; color: #fff; font-size: 50px; line-height: 200%; } .flex>li:nth-of-type(3n){ /* 选择个数是3的倍数的元素 */ margin-right: 0; } .flex>li:nth-of-type(n+7){ /* 选择倒数的三个元素，n可以取0 */ margin-bottom: 0; }","comments":true,"tags":[{"name":"随笔","slug":"随笔","permalink":"https://climbsnail.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"树莓派测试SPI接口","date":"2019-04-07T15:27:09.000Z","path":"2019/树莓派测试SPI接口/","text":"代码12345678910111213141516171819202122232425262728293031/* * SPI testing utility (using spidev driver) * * Copyright (c) 2007 MontaVista Software, Inc. * Copyright (c) 2007 Anton Vorontsov &lt;avorontsov@ru.mvista.com&gt; * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation; either version 2 of the License. * * Cross-compile with cross-gcc -I/path/to/cross-kernel/include */ #include &lt;stdint.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;getopt.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/ioctl.h&gt; #include &lt;linux/types.h&gt; #include &lt;linux/spi/spidev.h&gt; #define ARRAY_SIZE(a) (sizeof(a)/sizeof((a)[0])) static void pabort(const char *s) &#123; perror(s); abort(); &#125; 下面这段代码衔接到上面那段的后边(都放一个.c文里) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183static const char *device = \"/dev/spidev0.1\"; static uint8_t mode; static uint8_t bits = 8; //static uint32_t speed = 500000; static uint32_t speed = 20000000; static uint16_t delay; static void transfer(int fd) &#123; int ret; uint8_t tx[] = &#123; 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x40, 0x00, 0x00, 0x00, 0x00, 0x95, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDE, 0xAD, 0xBE, 0xEF, 0xBA, 0xAD, 0xF0, 0x0D, &#125;; uint8_t rx[ARRAY_SIZE(tx)] = &#123;0, &#125;; struct spi_ioc_transfer tr = &#123; .tx_buf = (unsigned long)tx, .rx_buf = (unsigned long)rx, .len = ARRAY_SIZE(tx), .delay_usecs = delay, .speed_hz = speed, .bits_per_word = bits, &#125;; ret = ioctl(fd, SPI_IOC_MESSAGE(1), &amp;tr); if (ret &lt; 1) pabort(\"can't send spi message\"); for (ret = 0; ret &lt; ARRAY_SIZE(tx); ret++) &#123; if (!(ret % 6)) puts(\"\"); printf(\"%.2X \", rx[ret]); &#125; puts(\"\"); &#125; static void print_usage(const char *prog) &#123; printf(\"Usage: %s [-DsbdlHOLC3]\\n\", prog); puts(\" -D --device device to use (default /dev/spidev1.1)\\n\" \" -s --speed max speed (Hz)\\n\" \" -d --delay delay (usec)\\n\" \" -b --bpw bits per word \\n\" \" -l --loop loopback\\n\" \" -H --cpha clock phase\\n\" \" -O --cpol clock polarity\\n\" \" -L --lsb least significant bit first\\n\" \" -C --cs-high chip select active high\\n\" \" -3 --3wire SI/SO signals shared\\n\"); exit(1); &#125; static void parse_opts(int argc, char *argv[]) &#123; while (1) &#123; static const struct option lopts[] = &#123; &#123; \"device\", 1, 0, 'D' &#125;, &#123; \"speed\", 1, 0, 's' &#125;, &#123; \"delay\", 1, 0, 'd' &#125;, &#123; \"bpw\", 1, 0, 'b' &#125;, &#123; \"loop\", 0, 0, 'l' &#125;, &#123; \"cpha\", 0, 0, 'H' &#125;, &#123; \"cpol\", 0, 0, 'O' &#125;, &#123; \"lsb\", 0, 0, 'L' &#125;, &#123; \"cs-high\", 0, 0, 'C' &#125;, &#123; \"3wire\", 0, 0, '3' &#125;, &#123; \"no-cs\", 0, 0, 'N' &#125;, &#123; \"ready\", 0, 0, 'R' &#125;, &#123; NULL, 0, 0, 0 &#125;, &#125;; int c; c = getopt_long(argc, argv, \"D:s:d:b:lHOLC3NR\", lopts, NULL); if (c == -1) break; switch (c) &#123; case 'D': device = optarg; break; case 's': speed = atoi(optarg); break; case 'd': delay = atoi(optarg); break; case 'b': bits = atoi(optarg); break; case 'l': mode |= SPI_LOOP; break; case 'H': mode |= SPI_CPHA; break; case 'O': mode |= SPI_CPOL; break; case 'L': mode |= SPI_LSB_FIRST; break; case 'C': mode |= SPI_CS_HIGH; break; case '3': mode |= SPI_3WIRE; break; case 'N': mode |= SPI_NO_CS; break; case 'R': mode |= SPI_READY; break; default: print_usage(argv[0]); break; &#125; &#125; &#125; int main(int argc, char *argv[]) &#123; int ret = 0; int fd; parse_opts(argc, argv); fd = open(device, O_RDWR); if (fd &lt; 0) pabort(\"can't open device\"); /* * spi mode */ ret = ioctl(fd, SPI_IOC_WR_MODE, &amp;mode); if (ret == -1) pabort(\"can't set spi mode\"); ret = ioctl(fd, SPI_IOC_RD_MODE, &amp;mode); if (ret == -1) pabort(\"can't get spi mode\"); /* * bits per word */ ret = ioctl(fd, SPI_IOC_WR_BITS_PER_WORD, &amp;bits); if (ret == -1) pabort(\"can't set bits per word\"); ret = ioctl(fd, SPI_IOC_RD_BITS_PER_WORD, &amp;bits); if (ret == -1) pabort(\"can't get bits per word\"); /* * max speed hz */ ret = ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, &amp;speed); if (ret == -1) pabort(\"can't set max speed hz\"); ret = ioctl(fd, SPI_IOC_RD_MAX_SPEED_HZ, &amp;speed); if (ret == -1) pabort(\"can't get max speed hz\"); printf(\"spi mode: %d\\n\", mode); printf(\"bits per word: %d\\n\", bits); printf(\"max speed: %d Hz (%d KHz)\\n\", speed, speed/1000); transfer(fd); close(fd); return ret; &#125; 操作 先用gcc编译1gcc spidev_test.c 将树莓派的MISO和MOSI引脚短接，运行命令1sudo modprobe spi_bcm2835 运行1sudo ./a.out 如果SPI正常启用了的话，会出现以下结果： 否则会出现下面的结果：","comments":true,"tags":[{"name":"教程","slug":"教程","permalink":"https://climbsnail.github.io/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"Raspberry系统备份","date":"2019-03-06T03:25:22.000Z","path":"2019/RaspberryBackup/","text":"前序之前复制或者备份树莓派的SD卡，都是用dd命令全盘复制，可以用，但是这样有两大缺点： 慢 一个大的SD卡，比如64G，即使只用了2G，经过dd命令生成的img文件也会生成一个和整个SD卡容量一样大小的文件，即64G。 于是，需要有一个可以解决上述问题的制作树莓派SD卡img映像文件的方法。 在网上搜索了一些，做了些研究，发现还是有办法的。 如下列网址所述：（感谢作者）http://www.cnblogs.com/haochuang/p/6066532.html 准备 准备一个树莓派Raspberry Pi和另外的Raspbian系统，并启动，用来作为备份操作的环境。要保证这个系统所在的SD卡的空间够大（我用了64G的卡，虽然没有必要这么大），足够用来保存img备份文件。 ps:用PC上的其他Linux系统也可以，比如Debian 9.3。 而且用PC会快一些。 准备好要备份的SD卡，和USB读卡器。 将插好源SD卡的读卡器插入树莓派（或PC）。 首先安装必需的工具软件： 1pi@raspberrypi:~ $ sudo apt-get install dosfstools dump parted kpartx 建立工作目录123pi@raspberrypi:~ $ mkdir ~/backupimgpi@raspberrypi:~ $ cd ~/backupimgpi@raspberrypi:~/backupimg $ 生成空白img文件确定设备插入装有源SD卡的读卡器到USB口后，确定源SD卡对应的设备名 12pi@raspberrypi:~/backupimg $ ls /dev/sd*/dev/sda /dev/sda1 /dev/sda2 如上所示/dev/sda为源SD卡，/dev/sda1为/boot，/dev/sda2为/（根）。 不同的系统会有所不同，可能会是sdb…或其他，例如： 12yang@debian:~/backupimg$ ls /dev/sd*/dev/sda /dev/sda1 /dev/sda2 /dev/sda5 /dev/sdb /dev/sdb1 /dev/sdb2 挂载源SD卡 新建目录挂载123pi@raspberrypi:~/backupimg $ mkdir src_boot src_Rootpi@raspberrypi:~/backupimg $ sudo mount -t vfat -o uid=pi,gid=pi,umask=0000 /dev/sda1 ./src_boot/pi@raspberrypi:~/backupimg $ sudo mount -t ext4 /dev/sda2 ./src_Root/ 请注意，我用的是另一个raspberry系统做备份操作的，如果是用其他linux系统，例如PC上的Debian，请注意uid和gid的设置，上述第2，3条命令可能会是： 12yang@debian:~/backupimg$ sudo mount -t vfat -o uid=yang,gid=yang,umask=0000 /dev/sdb1 ./src_boot/yang@debian:~/backupimg$ sudo mount -t ext4 /dev/sdb2 ./src_Root/ 查看源SD卡已用空间大小123456789101112pi@raspberrypi:~/backupimg $ df -hFilesystem Size Used Avail Use% Mounted on/dev/root 59G 6.1G 51G 11% /devtmpfs 460M 0 460M 0% /devtmpfs 464M 0 464M 0% /dev/shmtmpfs 464M 13M 452M 3% /runtmpfs 5.0M 4.0K 5.0M 1% /run/locktmpfs 464M 0 464M 0% /sys/fs/cgroup/dev/mmcblk0p1 42M 21M 21M 51% /boottmpfs 93M 0 93M 0% /run/user/1000/dev/sda1 56M 21M 36M 37% /home/pi/backupimg/src_boot/dev/sda2 15G 4.0G 9.9G 29% /home/pi/backupimg/src_Root 如上可以看出/dev/sda已用空间大约4G 创建空img文件 创建空白img文件因为源SD卡已用空间大约4G，那么建立一个4600M的空白img文件应该够了。（安全起见，设定5000会更好）1234pi@raspberrypi:~/backupimg $ sudo dd if=/dev/zero of=raspberrypi.img bs=1M count=46004600+0 records in4600+0 records out4823449600 bytes (4.8 GB, 4.5 GiB) copied, 283.248 s, 17.0 MB/s 特别注意这里 bs=1M，千万不要写成1MB。1M是10241024 Bytes， 而1MB是10001000 Bytes，会造成img文件的大小不是512 bytes的整数倍，后面会报错。 这个过程大约几分钟完成。 如果比较着急，可以另开一个终端，运行如下命令，可以观察到img文件大小的变化。 1pi@raspberrypi:~ $ watch -d -n 5 ls -lh ~/backupimg 完成后，确认一下img文件已经生成，且文件大小正确12pi@raspberrypi:~/backupimg $ ls -l raspberrypi.img-rw-r--r-- 1 root root 4823449600 Dec 15 22:00 raspberrypi.img 查看分区信息(只关注sda项中的Start与End) 1pi@raspberrypi:~/backupimg $ sudo fdisk -l 给img文件分区123pi@raspberrypi:~/backupimg $ sudo parted raspberrypi.img --script -- mklabel msdospi@raspberrypi:~/backupimg $ sudo parted raspberrypi.img --script -- mkpart primary fat32 8192s 122479spi@raspberrypi:~/backupimg $ sudo parted raspberrypi.img --script -- mkpart primary ext4 122880s -1 分区的起始扇区数都是 8192 的倍数，以保证4k对齐检查分区是否成功 123456789101112131415161718pi@raspberrypi:~/backupimg $ sudo parted raspberrypi.imgGNU Parted 3.2Using /home/pi/backupimg/raspberrypi.imgWelcome to GNU Parted! Type 'help' to view a list of commands.(parted) print free Model: (file)Disk /home/pi/backupimg/raspberrypi.img: 4823MBSector size (logical/physical): 512B/512BPartition Table: msdosDisk Flags: Number Start End Size Type File system Flags 16.4kB 4194kB 4178kB Free Space 1 4194kB 62.7MB 58.5MB primary lba 62.7MB 62.9MB 205kB Free Space 2 62.9MB 4822MB 4759MB primary 4822MB 4823MB 1049kB Free Space(parted) quit 在parted程序中，输入print free命令可以显示分区内容，输入quit退出 挂载img文件到系统img文件对应的Loop device的设置 12pi@raspberrypi:~/backupimg $ sudo losetup -f --show raspberrypi.img/dev/loop0 下面的命令中相应输入/dev/loop0，如果不是 loop0 请做相应调整（以及以后的各个步骤里的loop0都要改变） 123456pi@raspberrypi:~/backupimg $ sudo kpartx -va /dev/loop0add map loop0p1 (254:0): 0 114288 linear 7:0 8192add map loop0p2 (254:1): 0 9295872 linear 7:0 122880pi@raspberrypi:~/backupimg $ ls /dev/mapper/loop0p*/dev/mapper/loop0p1 /dev/mapper/loop0p2 此时loop device就设置好了，loop0p1对应的是img文件分区上的 /boot，loop0p2对应的是 /（根） 给img文件中的两个分区格式化123456789101112131415pi@raspberrypi:~/backupimg $ sudo mkfs.vfat -n boot /dev/mapper/loop0p1mkfs.fat 4.1 (2017-01-24)mkfs.fat: warning - lowercase labels might not work properly with DOS or Windowspi@raspberrypi:~/backupimg $ sudo mkfs.ext4 /dev/mapper/loop0p2mke2fs 1.43.4 (31-Jan-2017)Discarding device blocks: done Creating filesystem with 1161984 4k blocks and 290880 inodesFilesystem UUID: d3e5d272-7752-48b2-a10e-e0e6d217ca7eSuperblock backups stored on blocks: 32768, 98304, 163840, 229376, 294912, 819200, 884736Allocating group tables: done Writing inode tables: done Creating journal (16384 blocks): doneWriting superblocks and filesystem accounting information: done 挂载目标img文件loop device123pi@raspberrypi:~/backupimg $ mkdir tgt_boot tgt_Rootpi@raspberrypi:~/backupimg $ sudo mount -t vfat -o uid=pi,gid=pi,umask=0000 /dev/mapper/loop0p1 ./tgt_boot/pi@raspberrypi:~/backupimg $ sudo mount -t ext4 /dev/mapper/loop0p2 ./tgt_Root/ 请注意，我用的是另一个raspberry系统做备份操作的，如果是用其他linux系统，请注意uid和gid的设置，上述第2，3条命令可能会是： 12yang@debian:~/backupimg$ sudo mount -t vfat -o uid=yang,gid=yang,umask=0000 /dev/mapper/loop0p1 ./tgt_boot/yang@debian:~/backupimg$ sudo mount -t ext4 /dev/mapper/loop0p2 ./tgt_Root/ 备份/boot首先备份/boot，直接拷贝即可 1pi@raspberrypi:~/backupimg $ sudo cp -rfp ./src_boot/* ./tgt_boot/ 备份“/”备份根文件系统稍微复杂些，可以用两种方法 方法一、dump/restore方法首先对目标挂载点设置合适的权限，并清空 1234pi@raspberrypi:~/backupimg $ sudo chmod 777 tgt_Rootpi@raspberrypi:~/backupimg $ sudo chown pi.pi tgt_Rootpi@raspberrypi:~/backupimg $ sudo rm -rf ./tgt_Root/*pi@raspberrypi:~/backupimg $ cd tgt_Root/ 请注意，我用的是另一个raspberry系统做备份操作的，如果是用其他linux系统，请注意uid和gid的设置，上述第2条命令可能会是： 1yang@debian:~/backupimg$ sudo chown yang.yang tgt_Root 然后开始备份 12345678910111213141516171819202122pi@raspberrypi:~/backupimg/tgt_Root $ sudo dump -0uaf - ../src_Root/ | sudo restore -rf - DUMP: Date of this level 0 dump: Fri Dec 15 22:22:34 2017 DUMP: Dumping /dev/sda2 (/home/pi/backupimg/src_Root) to standard output DUMP: Label: none DUMP: Writing 10 Kilobyte records DUMP: mapping (Pass I) [regular files] DUMP: mapping (Pass II) [directories] DUMP: estimated 4241064 blocks. DUMP: Volume 1 started with block 1 at: Fri Dec 15 22:22:35 2017 DUMP: dumping (Pass III) [directories] DUMP: dumping (Pass IV) [regular files] DUMP: 62.53% done at 8780 kB/s, finished in 0:03 DUMP: Volume 1 completed at: Fri Dec 15 22:30:36 2017 DUMP: Volume 1 4242680 blocks (4143.24MB) DUMP: Volume 1 took 0:08:01 DUMP: Volume 1 transfer rate: 8820 kB/s DUMP: 4242680 blocks (4143.24MB) DUMP: finished in 481 seconds, throughput 8820 kBytes/sec DUMP: Date of this level 0 dump: Fri Dec 15 22:22:34 2017 DUMP: Date this dump completed: Fri Dec 15 22:30:36 2017 DUMP: Average transfer rate: 8820 kB/s DUMP: DUMP IS DONE 整个dump/restore过程需要几分钟时间，看到 DUMP IS DONE 就说明备份成功了 然后返回上层目录 12pi@raspberrypi:~/backupimg/tgt_Root $ cd ..pi@raspberrypi:~/backupimg $ 方法二、tar方法如果上述方法一的 sudo dump … 那一步出现 Broken pipe、 Illegal instruction等错误而失败的话，可以使用方法二。这个方法会使用tar把源SD卡的根文件系统打包，所以在本机系统空间里需要额外的和源SD卡的根文件系统已用空间大小一样的可用空间。 首先，和方法一里面一样，对目标挂载点设置合适的权限，并清空 123pi@raspberrypi:~/backupimg $ sudo chmod 777 tgt_Rootpi@raspberrypi:~/backupimg $ sudo chown pi.pi tgt_Rootpi@raspberrypi:~/backupimg $ sudo rm -rf ./tgt_Root/* 请注意，我用的是另一个raspberry系统做备份操作的，如果是用其他linux系统，请注意uid和gid的设置，上述第2条命令可能会是： 1yang@debian:~/backupimg$ sudo chown yang.yang tgt_Root 然后用tar把源SD卡的根文件系统打包 12pi@raspberrypi:~/backupimg $ cd src_Root/pi@raspberrypi:~/backupimg/src_Root $ sudo tar pcf ../backup.tar . # 最后面有个”.”号 tar的过程中可能会出现一些 socket ignored 错误，可以忽略。 此过程可能需要比较长的时间，可另外开一个终端，运行如下命令，用来观察backup.tar文件大小的变化。 1pi@raspberrypi:~ $ watch -d -n 5 ls -lh ~/backupimg 上述打包过程结束后，接着将tar包解开到目标img文件的根文件系统 12pi@raspberrypi:~/backupimg $ cd ../tgt_Root/pi@raspberrypi:~/backupimg/tgt_Root $ sudo tar pxf ../backup.tar 此过程可能需要比较长的时间，可另外开一个终端，运行如下命令，用来观察目标img文件的根文件系统的已用空间大小变化 1pi@raspberrypi:~ $ watch -d -n 5 df -h```sh 解包过程结束后，回到上层目录，并删除backup.tar文件 123pi@raspberrypi:~/backupimg/tgt_Root $ cd ..pi@raspberrypi:~/backupimg $ sudo rm backup.tar pi@raspberrypi:~/backupimg $ 相应修改PARTUUID设定这时候整个备份就已经完成了。不过此时的img文件即使写入到空白SD卡里面也是无法启动的，因为Raspbian启动要对应分区的PARTUUID，所以我们还要修改目标img文件里的如下两个文件： 12./tgt_boot/cmdline.txt ./tgt_Root/etc/fstab 首先查看img文件对应的loop device的两个分区的PARTUUID 123456789pi@raspberrypi:~/backupimg $ sudo blkid/dev/mmcblk0p1: LABEL=\"boot\" UUID=\"E5B7-FEA1\" TYPE=\"vfat\" PARTUUID=\"ddffe93a-01\"/dev/mmcblk0p2: UUID=\"b4ea8e46-fe87-4ddd-9e94-506c37005ac5\" TYPE=\"ext4\" PARTUUID=\"ddffe93a-02\"/dev/sda2: UUID=\"9a7608bd-5bff-4dfc-ac1d-63a956744162\" TYPE=\"ext4\" PARTUUID=\"ec04fe79-02\"/dev/loop0: PTUUID=\"af2f8761\" PTTYPE=\"dos\"/dev/mmcblk0: PTUUID=\"ddffe93a\" PTTYPE=\"dos\"/dev/sda1: LABEL=\"boot\" UUID=\"B60A-B262\" TYPE=\"vfat\" PARTUUID=\"ec04fe79-01\"/dev/mapper/loop0p1: SEC_TYPE=\"msdos\" LABEL=\"boot\" UUID=\"755C-C29C\" TYPE=\"vfat\" PARTUUID=\"af2f8761-01\"/dev/mapper/loop0p2: UUID=\"a174c97e-049f-4fbd-abb7-0b9098dae24a\" TYPE=\"ext4\" PARTUUID=\"af2f8761-02\" 这里可以看到/boot对应的是af2f8761-01 ， / 对应的是af2f8761-02 修改 cmdline.txt 文件 123pi@raspberrypi:~/backupimg $ sudo vi ./tgt_boot/cmdline.txt pi@raspberrypi:~/backupimg $ cat ./tgt_boot/cmdline.txt dwc_otg.lpm_enable=0 console=serial0,115200 console=tty1 root=PARTUUID=af2f8761-02 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait 修改 fstab 文件 1234567pi@raspberrypi:~/backupimg $ sudo vi ./tgt_Root/etc/fstab pi@raspberrypi:~/backupimg $ cat ./tgt_Root/etc/fstab proc /proc proc defaults 0 0PARTUUID=af2f8761-01 /boot vfat defaults 0 2PARTUUID=af2f8761-02 / ext4 defaults,noatime 0 1# a swapfile is not a swap partition, no line here# use dphys-swapfile swap[on|off] for that 卸载各个挂载的分区 1pi@raspberrypi:~/backupimg $ sudo umount src_boot src_Root tgt_boot tgt_Root 删除loop device 12pi@raspberrypi:~/backupimg $ sudo kpartx -d /dev/loop0pi@raspberrypi:~/backupimg $ sudo losetup -d /dev/loop0 删除挂载点目录 1pi@raspberrypi:~/backupimg $ rmdir src_boot src_Root tgt_boot tgt_Root 最后剩下img文件 123pi@raspberrypi:~/backupimg $ ls -ltotal 4469676-rw-r--r-- 1 root root 4823449600 Dec 15 23:10 raspberrypi.img 大功告成完成之后可以用dd或者Etcher烧写img文件到其他SD卡中，注意烧写到新卡中在树莓派中运行后，要先用raspi-config先把分区空间expand一下，否则可用空间会很小。 拷贝（移动）镜像挂载windows共享磁盘1sudo mount -t cifs -o username=\"Hello World\",password=\"HQ\" //192.168.31.141/Raspberry /home/pi/share 将刚制作的镜像复制到windows上1sudo cp ./backupimg/RPi_OpenCV.img ./share","comments":true,"tags":[{"name":"教程","slug":"教程","permalink":"https://climbsnail.github.io/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"资源站点","date":"2018-08-08T13:40:42.000Z","path":"2018/download/","text":"个人资源共享站点请收藏本网址，站点入口可能会变化，但本网址永久保留！！！ 利用家中的NAS搭建的资源站点。进入资源站点后，通过右上角搜索功能即可搜索资源。请进入站点一键跳转。 备用站点1 备用站点2 目录介绍 EBook 存放电子书 SoftwarePackage 存放各类软件安装包 MyProject 存放本人已完成的项目 Wallpaper 存放壁纸 注：如资源无效请联系 QQ773181861 或邮箱climbsnail@qq.com 授之以鱼，不如授之以渔以下是搜索电子书的常用链接 https://cloud.189.cn/t/jmA7rmRVFr22 访问码ksx8 https://ebook.ipfs-lab.com/ https://www.shiyisoushu.com/ https://tstrs.me/1473.html","comments":true,"tags":[{"name":"资源","slug":"资源","permalink":"https://climbsnail.github.io/tags/%E8%B5%84%E6%BA%90/"}]},{"title":"让搜索引擎收录博客","date":"2018-06-08T12:52:47.000Z","path":"2018/让搜索引擎收录博客/","text":"验证站点网站在没有提交搜索引擎收录之前，直接搜索你网站的内容是搜不到的，只有提交搜索引擎之后，搜索引擎才能收录你的站点，通过爬虫抓取你网站的东西，对于hexo 博客来说，如果你是部署在GitHub Pages，那么你是无法被百度收录的，因为GitHub 禁止了百度爬虫，最常见的解决办法是双线部署到Coding Pages和GitHub Pages，因为百度爬虫可以爬取到Coding上的内容，从而实现百度收录。另外百度收录的所需的时间较长，大约半个月左右才会看到效果！ 生成站点地图打开终端 cd 到本地博客目录下，输入以下命令安装sitmap插件。 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 打开本地博客目录下的_config.yml文件，修改url参数为你博客的 首页地址，这样是为了保证能正确生成sitemap.xml文件中的地址。 1234url: https://climbsnail.github.io # 修改成你博客的首页地址root: /permalink: :year/:month/:day/:title/permalink_defaults: 添加以下配置。 12345# 自动生成sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 输入以下命令重新部署博客。 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 将站点地图提交百度搜索访问百度搜索资源平台官网。 注册或者登陆百度账号，依次选择页面上方的[用户中心]-[站点管理]，添加你的网站，在添加站点时会让你选择协议头（http 或者 https）。添加完网站之后，点击站点管理里目标站点进行下方的收录设置。如果选择 https，它会验证你的站点，大约能在一天之内完成，我的网站已经实现了全站 https，因此选择了 https 协议，但是不知道为什么始终验证失败，实在是无解，只能选择http 协议了，如果你的站点也实现了全站 https，也可以尝试一下。 将站点地图提交谷歌打开谷歌站点控制台 进入站点控制台，选择第二项复制你的博客站点。点击继续。等待验证通过。确定左上角选择的站点为目标站点，然后添加站点地图，将站点的地图文件添加进区(确保仓库目录下已经有提交了这个地图文件)。提交完成后，就可以等待搜索引擎自动抓取或者配置自动推送或者主动推送站点链接了。如果你的博客是使用GitHub+Hexo搭建的，由于Github貌似禁止百度爬虫访问博客，导致博客可能无法被百度收录，所以可以主动推送站点链接。谷歌就不用担心这些了，基本上第二天就可以录入了。 Hexo搭建博客系列教程 Hexo搭建博客系列教程1__hexo+Github搭建个人静态博客 Hexo搭建博客系列教程2__Hexo安装配置yilia主题 Hexo搭建博客系列教程3__yilia主题添加网易云音乐插件 Hexo搭建博客系列教程4__yilia主题添加Gitment评论插件 Hexo搭建博客系列教程5__让搜索引擎收录博客","comments":true,"tags":[{"name":"静态博客搭建","slug":"静态博客搭建","permalink":"https://climbsnail.github.io/tags/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"yilia主题添加Gitment评论插件","date":"2018-06-06T08:53:23.000Z","path":"2018/yilia主题添加Gitment评论插件/","text":"Gitment评论插件的使用 Gitment模块 Gitment 是基于 GitHub Issues 的评论系统。 支持在前端直接引入，不需要任何后端代码。 可以在页面进行登录、查看、评论、点赞等操作. 同时有完整的 Markdown / GFM 和代码高亮支持。 尤为适合各种基于 GitHub Pages 的静态博客或项目页面。 想了解具体效果，可以点击查看官方Demo Page：Gitment Demo。 注册 OAuth Application 首先在点击注册自己OAuth Application 填写相关信息，注意：在Authorization callback URL填自己的网站url，例如我的https://climbsnail.github.io 创建成功后，你会得到一个client ID和一个client secret，这个将被用于之后的用户登录。 修改yilia的配置文件_config.yml12345678#5、Gitmentgitment_owner: ClimbSnail #你的 GitHub IDgitment_repo: &#39;Gitment&#39; #存储评论的 repogitment_oauth: client_id: &#39;&#39; #client ID client_secret: &#39;&#39; #client secret # 其中的client ID 和 client secret换成你自己的就行了。 Hexo搭建博客系列教程 Hexo搭建博客系列教程1__hexo+Github搭建个人静态博客 Hexo搭建博客系列教程2__Hexo安装配置yilia主题 Hexo搭建博客系列教程3__yilia主题添加网易云音乐插件 Hexo搭建博客系列教程4__yilia主题添加Gitment评论插件 Hexo搭建博客系列教程5__让搜索引擎收录博客","comments":true,"tags":[{"name":"静态博客搭建","slug":"静态博客搭建","permalink":"https://climbsnail.github.io/tags/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"yilia主题添加网易云音乐插件","date":"2018-06-06T06:35:43.000Z","path":"2018/yilia主题添加网易云音乐插件/","text":"添加网易云音乐播放插件 打开网易云音乐首页，复制选择的背景音乐分享外链 在网易云音乐 网页中选中想要使用的音乐，进入播放界面，点击生成外链播放器，这里由于版权问题，网易云音乐无法对有版权的音乐生成外链！！！2. 引入播放器代码 在themes/yilia/layout/_partial/left-col.ejs文件nav标签中添加如下代码，代码中id后的1334445174为默认音乐的id号 将代码中的红色部分和刚刚复制的网易云外链代码进行对照，将对应部分进行替换（不替换的话使用的是 纸短情长 歌曲） 123456&lt;!-- 网易云音乐插件 --&gt;&lt;% if (theme.music &amp;&amp; theme.music.enable)&#123; %&gt; &lt;div style=\"position:absolute; bottom:120px left:auto; width:85%\"&gt; &lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"240\" height=\"52\" src=\"//music.163.com/outchain/player?type=2&amp;id=&lt;%=theme.music.id||1433584979%&gt;&amp;auto=&lt;%=theme.music.autoplay?1:0%&gt;&amp;height=32\"&gt;&lt;/iframe&gt; &lt;/div&gt;&lt;% &#125; %&gt; 添加位置如图：3. 回到hexo的配置文件_config.yml新增以下配置，更换音乐只需要改动_config.yml文件此处的id号。 12345music: enable: true id: 1433584979 # 网易云分享的ID,ID可以随时替换 autoplay: true # 是否开启自动播放（注：在KeXueShangWang条件下，无法自动播放） Hexo搭建博客系列教程 Hexo搭建博客系列教程1__hexo+Github搭建个人静态博客 Hexo搭建博客系列教程2__Hexo安装配置yilia主题 Hexo搭建博客系列教程3__yilia主题添加网易云音乐插件 Hexo搭建博客系列教程4__yilia主题添加Gitment评论插件 Hexo搭建博客系列教程5__让搜索引擎收录博客","comments":true,"tags":[{"name":"静态博客搭建","slug":"静态博客搭建","permalink":"https://climbsnail.github.io/tags/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"Hexo安装配置yilia主题","date":"2018-06-06T02:13:12.000Z","path":"2018/Hexo安装配置yilia主题/","text":"最后的效果可参考本人博客 高级玩法之更换hexo主题使用hexo-theme-yilia主题 在命令行中确保在本博客的根目录下，输入以下命令。12git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia# 注：themes/yilia意为将本次下载下来的yilia主题放在themes目录下 修改本博客根目录的_config.yml文件中的theme字段的参数，更改为yilia。1theme: yilia 部分配置项介绍12favicon 为网页打开后的标签图标avatar 为网页主页的个人图标 文章截断功能文章篇幅大的时候，主页将会被长篇占据，影响美观。 Yilia中可以使用&lt;!– more –&gt;在目标文中标记(一定是在文章中)，表示当该文章在主页显示的时候，只展现&lt;!– more –&gt;标记之前的内容。 可以注释excerpt_link这个配置项，如下： 1# excerpt_link: more 开启tag栏的文章搜索修改yilia的_config.yml文件中的showTags配置项值为true。 1234# slider的设置slider: # 是否默认展开tags板块 showTags: true Yilia主题的所有文章功能不能用点击左侧”所有文章”无法正常使用，则请参考以下操作。 node.js版本必须6.2以上 在hexo根目录下执行命令： 1npm i hexo-generator-json-content --save 在hexo的配置文件_config.yml最后添加 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 删除页面右下角的”Hexo Theme Yilia by Litten” 1234打开themes\\yilia\\layout_partial\\footer.ejs,修改如下：&lt;div class=\"footer-right\"&gt;&lt;/div&gt; 添加后重新发布就行了。 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d Hexo搭建博客系列教程 Hexo搭建博客系列教程1__hexo+Github搭建个人静态博客 Hexo搭建博客系列教程2__Hexo安装配置yilia主题 Hexo搭建博客系列教程3__yilia主题添加网易云音乐插件 Hexo搭建博客系列教程4__yilia主题添加Gitment评论插件 Hexo搭建博客系列教程5__让搜索引擎收录博客","comments":true,"tags":[{"name":"静态博客搭建","slug":"静态博客搭建","permalink":"https://climbsnail.github.io/tags/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"hexo+Github搭建个人静态博客","date":"2018-06-06T00:18:12.000Z","path":"2018/hexo+Github搭建个人静态博客/","text":"最后的效果可参考本人博客 概要介绍本文主要使用hexo搭建静态博客，并使用Github作为挂载点。 Hexo简介Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。大家可以进入hexo官网进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。 Github简介Github是一个面向开源及私有软件项目的托管平台,因为只支持 Git 作为唯一的版本库格式进行托管,故名 GitHub。 搭建步骤 注册Github账号，并创建博客挂载点的仓库。 安装Nodejs 使用npm安装hexo 正式开始使用hexo 配置hexo 测试 详细搭建过程安装Git工具linux使用sudo apt-get install git安装git管理工具 windows访问Git官网下载合适系统的git版本并安装。 安装nodejslinux使用sudo apt-get install nodejs安装nodejs windows访问Nodejs官网下载合适系统的版本并安装。 以上操作结束，可使用node -v来检查Nodejs是否安装成功。 npm安装、cnpm安装linux使用sudo apt-get install npm安装npm windows cmd中直接执行下面命令(确保上面已经安装过Nodejs) 12345npm install -g cnpm --registry.npm.taobao.org# 安装无误后进行下面的hexo安装cnpm install -g hexo-clihexo -v # 来验证下hexo是否安装成功 初始化配置hexo1hexo init blog # 命令格式为hexo init [目录名] 添加了目录名这个选项，就会默认在当前页面创建目录并初始化。若不加用户名，则会在当前目录下初始化。 1234567配置hexo的_config.yml文件subtitle: 添加你的个签keywords: 添加你网站的关键字permalink 配置项指定了文章生成的结构，默认会以年月日的多层结构生成文件夹结构。多层目录结构影响了怕从程序的搜索，故简易目录结构越短越好，建议permalink如下配置permalink: :title&#x2F; # 只保留一层结构，即目录下直接单个文章名 启动hexo服务程序测试123hexo s或者hexo server 会启动hexo本地服务，通过http://localhost:4000就能访问预览。 浏览器访问上面的网址(打不开，可以更换浏览器再试试) 创建一篇文章1hexo n \"我的第一篇文章\" 文章创建完默认存放在source\\_posts目录下。可以使用vi或者其他的记事本工具编写文件（文章默认后缀.md）。 编写完后发布顺序执行以下命令 12hexo clean # 清理hexo g # 重新生成 再次使用hexo s启动运行hexo本地服务。到此为止已经成功搭建了基于本地的hexo个人博客。 部署到github仓库确认本地服务搭建成功后，就来部署到github远端仓库，这样就可以公网访问我们的静态博客了。 申请一个github账号此步骤操作有疑问，请参考百度、谷歌。 通过我们的github账号创建一个仓库github的hexo仓库名一定要是 github用户名.github.io，否则之后会报错。接下来的命令全都在hexo初始化的根目录进行。 本地安装hexo的git部署插件123cnpm install --save hexo-deployer-git或者使用以下命令cnpm install hexo-deployer-git --save 修改hexo配置如下，需要配置deploy 1234deploy: type: 'git' repo: https://github.com/你的git用户名/你的git用户名.github.io.git branch: master 部署到远端1hexo d 过程中会让输入github账号与密码两个步骤 可以刷新github对应仓库的页面，可以看到内容已经到github上了。实际上hexo只有网页相关的数据(public文件夹下的内容)会同步到github对应的仓库中。 通过访问https://climbsnail.github.io就可以访问我们的博客了。 Hexo搭建博客系列教程 Hexo搭建博客系列教程1__hexo+Github搭建个人静态博客 Hexo搭建博客系列教程2__Hexo安装配置yilia主题 Hexo搭建博客系列教程3__yilia主题添加网易云音乐插件 Hexo搭建博客系列教程4__yilia主题添加Gitment评论插件 Hexo搭建博客系列教程5__让搜索引擎收录博客","comments":true,"tags":[{"name":"静态博客搭建","slug":"静态博客搭建","permalink":"https://climbsnail.github.io/tags/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"Hexo搭建博客系列教程","date":"2018-06-05T23:18:12.000Z","path":"2018/搭建个人静态博客/","text":"Hexo搭建博客系列教程 Hexo搭建博客系列教程1__hexo+Github搭建个人静态博客 Hexo搭建博客系列教程2__Hexo安装配置yilia主题 Hexo搭建博客系列教程3__yilia主题添加网易云音乐插件 Hexo搭建博客系列教程4__yilia主题添加Gitment评论插件 Hexo搭建博客系列教程5__让搜索引擎收录博客 最后的效果可参考本人博客","comments":true,"tags":[{"name":"静态博客搭建","slug":"静态博客搭建","permalink":"https://climbsnail.github.io/tags/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"大家好，自我介绍一下。","date":"2018-06-05T22:48:36.000Z","path":"2018/from_now_on/","text":"开篇今天起，开始长期维护这个小博客了。 目的 记录个人学习技术过程中的心得。 分享我是如何给自己挖坑，并偷别人填坑的材料来填自己的坑。","comments":true,"tags":[{"name":"随笔","slug":"随笔","permalink":"https://climbsnail.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}]